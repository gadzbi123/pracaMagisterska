\chapter{[Tytuł rozdziału]}  % Analiza tematu
% 

%\begin{itemize}
%\item Jaki problem chcę (muszę :-) rozwiązać?
%\item Dlaczego rozwiązanie problemu jest ważne?
%\item Jak inni rozwiązują ten problem?
%\item Jakie są zalety i wady tych rozwiązań?
%\end{itemize}

Odwołania do literatury:
książek \cite{bib:ksiazka},
artykułów w czasopismach \cite{bib:artykul},
materiałów konferencyjnych \cite{bib:konferencja}
i stron www \cite{bib:internet}.

Równania powinny być numerowane
\begin{align}
    y = \frac{\partial x}{\partial t}
\end{align}

%
%\begin{itemize}
%\item analiza tematu
%\item wprowadzenie do dziedziny (\english{state of the art}) – sformułowanie problemu, 
%\item poszerzone studia literaturowe, przegląd literatury tematu (należy wskazać źródła wszystkich informacji zawartych w pracy)
%\item opis znanych rozwiązań, algorytmów, osadzenie pracy w kontekście
%\item Tytuł rozdziału jest często zbliżony do tematu pracy. 
%\item Rozdział jest wysycony cytowaniami do literatury \cite{bib:artykul,bib:ksiazka,bib:konferencja}. 
%Cytowanie książki \cite{bib:ksiazka}, artykułu w czasopiśmie \cite{bib:artykul}, artykułu konferencyjnego \cite{bib:konferencja} lub strony internetowej \cite{bib:internet}.
%\end{itemize}

%\begin{Definition}\label{def:1}
%Definicja to zdanie (lub układ zdań) odpowiadające na pytanie o strukturze „co to jest a?”. Definicja normalna jest zdaniem złożonym z 2 członów: definiowanego (łac. definiendum) i definiującego (łac. definiens), połączonych spójnikiem definicyjnym („jest to”, „to tyle, co” itp.). 
%\end{Definition}
%
%\begin{Theorem}[Pitagorasa]\label{t:pitagoras}
%W dowolnym trójkącie prostokątnym suma kwadratów długości przyprostokątnych jest równa kwadratowi długości przeciwprostokątnej tego trójkąta. 
%\end{Theorem}
%
%\begin{Example}[generalizacja]\label{ex:generalizacja}
%Przykładem generalizacji jest para: zwierzę i pies. Pies jest zwierzęciem. Pies jest uszczegółowieniem pojęcia zwierzę. Zwierzę jest uogólnieniem pojęcia pies.
%\end{Example}

Podjęcie problemu wyszukiwania plików po nazwach oraz zawartości jest bardzo
złożonym i trudnym problemem w sferze programistycznej. Istnieje wiele rozwiązań
tego problemu, które istnieją od początku pracy z komputerem. Narzędzia takie
jak find, grep czy fzf pozwalają na wyszukiwanie zawartości która nas interesuje,
ale kompleksowość tych narzędzi nie jest przystosowana do tak trudnego problemu,
jakim jest wyszukiwanie treści w plikach, które są zarchiwizowane. Z taką samą
niedogodnością spotykamy się w przypadku plików pochodzących z pakietu Microsoft
Office 365, jednak jeśli rozwiążemy zadanie otrzymywania zawartości z archiwów,
będziemy w stanie otrzymać również zawartość z plików z rozszerzeniami .doc,
.docx czy .pptx.

Narzędzie \textbf{find} to znane i popularne narzędzie wśród osób zaznajomionych z
technologiami linuxowymi. Już bardzo często wykorzystywany do znajdowania plików
w systemie, jednak nie nadaje sie do znajdowania zawartości plików.

\begin{lstlisting}[language=bash]
# Rezultat komendy tldr find
# Find files by extension:
    find root_path -name '*.ext'

# Find files matching multiple path/name patterns:
    find root_path -path '**/path/**/*.ext' -or -name '*pattern*'

# Find directories matching a given name, in case-insensitive mode:
    find root_path -type d -iname '*lib*'

# Find files matching a given pattern, excluding specific paths:
    find root_path -name '*.py' -not -path '*/site-packages/*'

# Find files matching a given size range, limiting the recursive depth to "1":
    find root_path -maxdepth 1 -size +500k -size -10M

# Run a command for each file (use `{}` within the command to access the filename):
    find root_path -name '*.ext' -exec wc -l {} \;

# Find all files modified today and pass the results to a single command as arguments:
    find root_path -daystart -mtime -1 -exec tar -cvf archive.tar {} \+

# Find empty (0 byte) files and delete them:
    find root_path -type f -empty -delete
\end{lstlisting}

Do przeszukiwania zawartości plików dobrze nadaje się narzędzie grep, który jest
dostępny w każdej dystrybucji linuxa. Jego działanie jest dość podobne do finda,
lecz posiada on możliwość wyszukiwania treść w plikach tekstowych jak również
archiwach. Nie posiada on niestety możliwość szukania zawartości plików .pdf oraz
nie wspiera formatów książkowych takich jak .djvu.
\begin{lstlisting}[language=bash]
# Rezultat komendy tldr grep 

# Search for a pattern within a file:
    grep "search_pattern" path/to/file

# Search for an exact string (disables regular expressions):
    grep -F|--fixed-strings "exact_string" path/to/file

# Search for a pattern in all files recursively in a directory, showing line numbers of matches, ignoring binary files:
    grep -r|--recursive -n|--line-number --binary-files without-match "search_pattern" path/to/directory

# Use extended regular expressions (supports `?`, `+`, `{}`, `()` and `|`), in case-insensitive mode:
    grep -E|--extended-regexp -i|--ignore-case "search_pattern" path/to/file

# Print 3 lines of context around, before, or after each match:
    grep --context|before-context|after-context 3 "search_pattern" path/to/file

# Print file name and line number for each match with color output:
    grep -H|--with-filename -n|--line-number --color=always "search_pattern" path/to/file

# Search for lines matching a pattern, printing only the matched text:
    grep -o|--only-matching "search_pattern" path/to/file

# Search `stdin` for lines that do not match a pattern:
    cat path/to/file | grep -v|--invert-match "search_pattern"
\end{lstlisting}
Istnieje również ripgrep, który jest sukcesorem wcześniej wymienionego
narzędzia. Jego wydajność przewyższa grepa nawet trzydziestokrotnie w niektórych testach sprawnościowych,
jednak zazwyczaj jest to niewielki wzrost. Nie posiada on również wsparcia dla formatów pdf i djvu.

Można wyszukiwać również po treści piosenek ale było by to zbyt czasochłonne.

////////////////////////////////////////////////////////////////////////////////
Algorytm brute force

Jest wiele algorytmów, które wyszukują tekst. Jednym z takich algorytmów jest 
algorytm typu brute-force. Polega sprawdzaniu każdego bajtu, jego implementacja
jest bardzo prosta i standardowa, a złożoność czasowe tego rozwiązania wynosi
O(m * n), gdzie m to długość bloku (pattern), a n to długość tekstu (substring),
którego szukamy. 

```code
for i := 0; i<len(pattern); i++{
  for j := 0; j<len(substring); j++{
    // compare bytes
  }
}
```

Zaletą tego algorytmu jest to, że nie posiada potrzeby przechowywać żadnych 
danych w pamięci. Ten algorytm dobrze spradza się gdy posiadamy ograniczoną 
ilość zasobów pamięci, co nie jest problemem w obecnych czasach, gdy pamięć jest
stosunkowo tania i szerokodostępna.
https://ourworldindata.org/grapher/historical-cost-of-computer-memory-and-storage
https://jcmit.net/memoryprice.htm

Powyższy algorytm można zrównoleglić, dzieląc wzorzec na mniejsze części
i wyszukując tylko dane w tym obszarze, ale należy dołożyć końce wzorca, aby nie
wynikła sytuacja, w której wzorzec by wystąpił, ale nie wzięto pod uwagę końca 
zdania. 

Przykład
wzorzec     ABCABCABDABD
podłańcuch  BCA
rezultat:   4

Jeżeli podzielimy wzorzec na dwa procesy wyszukujące algorytmem brute-force,
otrzymamy dwa zadania:

Zadanie 1               Zadanie 2
wzorzec     ABCABC      wzorzec     ABDABD
podłańcuch  BCA         podłańcuch  BCA
rezultat:   -1          rezultat:   -1

Zrównoleglenie procesu powoduje, że otrzymaliśmy nie poprawny wynik, gdyż w 
żadnym z wzorców nie występuje podłańcuch "BCA", choć łańcuch występuje w 
miejscu 4, to algorytm nie posiada wiedzy o dalszej części wzorca.

Aby poprawić dany algorytm należy dołożyć znaki, które należy sprawdzać w 
przypadku poprawnego rozpatrzenia ostatniego znaku.

Zadanie 1               Zadanie 2
wzorzec     ABCABC(AB)  wzorzec     ABDABD(nil)
podłańcuch  BCA         podłańcuch  BCA
rezultat:   4           rezultat:   -1

W takim przypadku sprawdzamy tylko do sytuacji, w której BC jest częścią
podłańcucha, ale podłańcuch nie został w pełni znaleziony. Długość ponownego 
wyszukania byłaby równa len(podłańcuch) - 1.
